# CyberStart Game Volcano 5.4

For this challenge we were given the binary from the previous challenge and told to exploit a service running this program on the target.

First, we'll start by finding out more about the program. To see what protections are enabled we can use `checksec`.

```bash
┌──(finlay㉿kali)-[~/cd-5.4]
└─$ checksec repeater_skeeter
[*] '/home/finlay/cd-5.4/repeater_skeeter'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

NX is enabled, so this will prevent us from placing shellcode on the buffer and running it.
PIE is enabled, so this will make the addresses of the binary unpredictable without a memory leak.
RELRO is fully enabled, so if we gain abitrary write, we will only be able to write to certain areas in memory, preventing a GOT overwrite.
We can also assume ASLR is enabled on the target so we can't predict libc addresses without a memory leak.


Now, lets take a look at what the program does, I used Ghidra to disassemble it to try and understand the process.

```c
undefined4 main(undefined param_1)

{
  char local_114 [256];
  int local_14;
  undefined1 *local_10;
  
  local_10 = &param_1;
  local_14 = 0;
  puts("Xyz\'s Repeater Skeeter");
  fflush(stdout);
  while (local_14 == 0) {
    memset(local_114,0,0x100);
    fgets(local_114,0x256,stdin);
    printf(local_114);
    fflush(stdout);
  }
  return 0;
}
```

So we see that it prints a statement, clears the buffer and then enters a loop.

In the loop it clears a portion of memory, gets input from the user, prints that input, and then clears the buffer again.

The loop runs until a variable is overwritten.

The fatal mistake in this program is in the line `printf(local_114);`. It prints user input without using a format specifier which allows the user to input their own format specifier and leak data from the stack.

Let's see this in action:

```bash
┌──(finlay㉿kali)-[~/cd-5.4]
└─$ ./repeater_skeeter                                                                                                                                                                                                                                             

Xyz's Repeater Skeeter
%p %p %p
0x256 0xf7eb0580 0x56608637
```

We see that when we enter `%p` (which is the format specifier for printing an address) it prints some addresses from the stack. This is because of the lack of format specifier in the source code which means that when the user enters a format specifier, it starts trying to read arguments to print from the stack where they would usually be. There are no arguments on the stack, so `printf` will just print whatever is at the top. This is how we will leak the contents of memory.

If we enter `%p` over and over again we can read quite a few addresses from the stack and also read from a specific address, we can also write to addresses using `%n`. However, we don't know where to write to or what to write.

Our overall goal for the exploit is to overwrite part of the programs memory to redirect code execution and execute the `system` function with `/bin/sh` as the argument. So first we must find out the exact libc addresses of `system` and `/bin/sh` so that we can write them into memory.

This can be achieved by reading the addresses from the GOT (Global Offset Table) as RELRO is enabled, meaning the addresses are resolved as soon as the program is run instead of when it is needed.

To figure out the GOT addresses, we need to know the base address of the binary and their offsets from it. You can find the offsets by doing `objdump -R` on the binary.

```bash
┌──(finlay㉿kali)-[~/cd-5.4]
└─$ objdump -R repeater_skeeter

repeater_skeeter:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
00001ec0 R_386_RELATIVE    *ABS*
00001ec4 R_386_RELATIVE    *ABS*
00001ff8 R_386_RELATIVE    *ABS*
00002004 R_386_RELATIVE    *ABS*
00001fe4 R_386_GLOB_DAT    _ITM_deregisterTMCloneTable
00001fe8 R_386_GLOB_DAT    __cxa_finalize@GLIBC_2.1.3
00001fec R_386_GLOB_DAT    __gmon_start__
00001ff0 R_386_GLOB_DAT    stdin@GLIBC_2.0
00001ff4 R_386_GLOB_DAT    stdout@GLIBC_2.0
00001ffc R_386_GLOB_DAT    _ITM_registerTMCloneTable
00001fcc R_386_JUMP_SLOT   printf@GLIBC_2.0
00001fd0 R_386_JUMP_SLOT   fflush@GLIBC_2.0
00001fd4 R_386_JUMP_SLOT   fgets@GLIBC_2.0
00001fd8 R_386_JUMP_SLOT   puts@GLIBC_2.0
00001fdc R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0
00001fe0 R_386_JUMP_SLOT   memset@GLIBC_2.0
```

We can see from this that the `printf` offset is `0x1fcc`, the `fflush` one is `0x1fd0` and so on.

These offsets are constant with the binary, so will be the same no matter what. What will change however, is the base address of the binary as PIE is enabled.

To find the base address of the binary each time it is run, we need to use our memory leak as it will change every time.

If we leak a bunch of addresses with `%p`, we can compare the addresses to the memory map that you can see with gdb. To connect gdb to the program while it is running, use `gdb -p $(pidof ./repeater_skeeter)`. If you then type `vmmap` you will see something like this:

```bash
gdb-peda$ vmmap
Start      End        Perm      Name
0x565f9000 0x565fa000 r-xp      /home/finlay/cd-5.4/repeater_skeeter
0x565fa000 0x565fb000 r--p      /home/finlay/cd-5.4/repeater_skeeter
0x565fb000 0x565fc000 rw-p      /home/finlay/cd-5.4/repeater_skeeter
0x568a5000 0x568c7000 rw-p      [heap]
0xf7d04000 0xf7d21000 r--p      /usr/lib32/libc-2.31.so
0xf7d21000 0xf7e76000 r-xp      /usr/lib32/libc-2.31.so
0xf7e76000 0xf7ee6000 r--p      /usr/lib32/libc-2.31.so
0xf7ee6000 0xf7ee7000 ---p      /usr/lib32/libc-2.31.so
0xf7ee7000 0xf7ee9000 r--p      /usr/lib32/libc-2.31.so
0xf7ee9000 0xf7eeb000 rw-p      /usr/lib32/libc-2.31.so
0xf7eeb000 0xf7eed000 rw-p      mapped
0xf7f08000 0xf7f0a000 rw-p      mapped
0xf7f0a000 0xf7f0e000 r--p      [vvar]
0xf7f0e000 0xf7f10000 r-xp      [vdso]
0xf7f10000 0xf7f11000 r--p      /usr/lib32/ld-2.31.so
0xf7f11000 0xf7f2e000 r-xp      /usr/lib32/ld-2.31.so
0xf7f2e000 0xf7f39000 r--p      /usr/lib32/ld-2.31.so
0xf7f39000 0xf7f3a000 r--p      /usr/lib32/ld-2.31.so
0xf7f3a000 0xf7f3b000 rw-p      /usr/lib32/ld-2.31.so
0xff9e3000 0xffa04000 rw-p      [stack]
```

And if we compare the base address of the binary (`0x565f9000`) with the addresses we have leaked:

```bash
┌──(finlay㉿kali)-[~/cd-5.4]
└─$ ./repeater_skeeter
Xyz's Repeater Skeeter
%p %p %p
0x256 0xf7ee9580 0x565f9637
```

We can see that the third address is always `0x637` above the base address, this is our offset we can use to reliably calculate the base address every time the program is ran. You can test this by running the program multiple times and attaching gdb to it, as you will find the base address will change every time, but the offset will not.

Now that we can reliably calculate the GOT addresses of multiple function, we can read from these addresses using the format string exploit.

If we leak a bunch of addresses, we see that from the seventh one onwards the leaked value is `%p` in hex, this means we have leaked the part of the stack storing our own input, therefore using this discovery we can specify an address to read from using the syntax:

`address` + `%7$s`

We'll have to enter the address in little endian though for it to work, you can do this in python with `pack("<I", address)`, you can see in my code that I created a couple functions to make packing and unpacking addresses easier.

So now if we read from the GOT addresses of each function, we get the libc addresses.

The reason we want to know multiple libc addresses is because the libc version on the target is unknown, but if we know a few addresses and their corresponding functions we can match the version to a database online, such as [libc.blukat.me](https://libc.blukat.me/)

After entering the addresses into the website and finding the specific version from the database, we can now calculate the libc base at any time by subtracting the offset of any function as the offset is always the same.

With the libc base, we can also calculate the address of the `system` function and `/bin/sh` string using the offsets given by the database.

Now that we know the addresses we want to write, where do we write them?

We need the program to return from the main function into our system function by overwriting the EIP in the stack, we will also need to overwrite another address with the `/bin/sh` string so it is executed as an argument.

By analysing the addresses, we can leak and the structure of the stack with gdb attached, we find that the seventy-second leaked address corresponds to the address of the next instruction pointer and the argument address.

The address of the next instruction pointer is `0x4` lower than the leaked address, and the argument address is `0x4` higher than the leaked address.

Now comes the challenge of writing the addresses, the syntax for writing an address using a format string exploit is:

`address` + `address+2` + `%` + `first half` + `x%7$hn%` + `second half` + `x%8$hn`

Now this looks like a lot so let's break it down:

The way we write addresses with format string exploits is by writing the addresses in two halves. You write the addresses by taking the half and converting it to decimal, as that is how the `%n` specifier works.

`address` - The first half of the address that you are writing to

`address+2` - The second half of the address you are writing to

`first half` - The first half of the address you are writing (in decimal)

`second half` - The second half of the address you are writing (in decimal)

We use `%hn` to only write to half the address, so we can write the entire address in two parts.

Once the addresses have been written, we need the program to exit the loop of asking for user input and return into the system function. To do this we enter a string that is 256 characters or longer (not too long though or it will overwrite too much).

Then the main function will return into the system function and you should have a shell.